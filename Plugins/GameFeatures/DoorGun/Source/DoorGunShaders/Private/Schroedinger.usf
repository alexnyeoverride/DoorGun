#include "SharedHeader.usf"

RWTexture3D<float2> Ping;
RWTexture3D<float2> Pong;
bool PingPong;

RWStructuredBuffer<float4x4> InputTransforms;

[numthreads(8, 8, 8)]
void InitParticleSystem(uint3 ThreadId : SV_DispatchThreadID, uint3 GroupId : SV_GroupID)
{
	uint3 Id = uint3(8, 8, 8) * GroupId + ThreadId;
	
	uint NumParticles = 10;
	float2 WaveFunction = float2(0.0, 0.0);

	uint3 Sizes;
	Ping.GetDimensions(Sizes.x, Sizes.y, Sizes.z);

	for (int i = 0; i < NumParticles; i++)
	{
		float3 ParticlePos = float3(
			pow(7, 11 + i % 5) % Sizes.x,
			pow(7, 11 + i % 2) % Sizes.y,
			pow(7, 11 + i % 3) % Sizes.z
		);
		
		float3 ParticleOffset = ParticlePos - float3(Id);
		float ParticleDistSq = dot(ParticleOffset, ParticleOffset);
		float3 ParticleVel = ParticlePos;

		float Amplitude = exp(-ParticleDistSq); // gaussian wavepackets
		float Phase = dot(ParticleOffset, ParticleVel);
		WaveFunction += Amplitude * float2(cos(Phase), sin(Phase));
	}

	Ping[Id] = WaveFunction;
	Pong[Id] = WaveFunction;
}


// Propagates energy from neighboring cells, while conserving net energy in the system.
float2 ComputeLaplacian(uint3 GridPos, RWTexture3D<COMPLEX> Psi)
{
	COMPLEX Center = Psi.Load(GridPos);
	COMPLEX Laplacian = -6 * Center;

	uint3 Sizes;
	Ping.GetDimensions(Sizes.x, Sizes.y, Sizes.z);

	uint ZPlus = (GridPos.z + 1) % Sizes.z;
	// Add the side length before modulating so it's always a non-negative index.
	uint ZMinus = (GridPos.z + Sizes.z - 1) % Sizes.z;
	Laplacian += Psi.Load(uint3(GridPos.x, GridPos.y, ZPlus));
	Laplacian += Psi.Load(uint3(GridPos.x, GridPos.y, ZMinus));

	uint YPlus = (GridPos.y + 1) % Sizes.y;
	uint YMinus = (GridPos.y + Sizes.y - 1) % Sizes.y;
	Laplacian += Psi.Load(uint3(GridPos.x, YPlus, GridPos.z));
	Laplacian += Psi.Load(uint3(GridPos.x, YMinus, GridPos.z));

	uint XPlus = (GridPos.x + 1) % Sizes.x;
	uint XMinus = (GridPos.x + Sizes.x - 1) % Sizes.x;
	Laplacian += Psi.Load(uint3(XPlus, GridPos.y, GridPos.z));
	Laplacian += Psi.Load(uint3(XMinus, GridPos.y, GridPos.z));

	return Laplacian;
}

[numthreads(8, 8, 8)]
void Schroedinger(uint3 ThreadId : SV_DispatchThreadID, uint3 GroupId : SV_GroupID)
{
	uint3 Id = uint3(8, 8, 8) * GroupId + ThreadId;

	RWTexture3D<COMPLEX> ReadTexture = PingPong ? Pong : Ping;
	RWTexture3D<COMPLEX> WriteTexture = PingPong ? Ping : Pong;
	PingPong = !PingPong;

	float2 Laplacian = ComputeLaplacian(Id, ReadTexture);
	
	// Simplified hamiltonian with hbar and mass == 1.
	// The imaginary and real terms swap at each time-evolution.
	float2 Hamiltonian = float2(
		-Laplacian.y / 2,
		Laplacian.x / 2
	);

	WriteTexture[Id] = ReadTexture[Id] + Hamiltonian * DeltaTime;
}

// TODO check over
[numthreads(8, 8, 8)]
void GenerateTetrahedra(uint3 ThreadId : SV_DispatchThreadID)
{
	uint3 Id = uint3(8, 8, 8) * GroupId + ThreadId;
    
	// Get wavefunction value and compute probability
	RWTexture3D<COMPLEX> ReadTexture = PingPong ? Pong : Ping;
	COMPLEX WaveFunction = ReadTexture[Id];
	float Probability = dot(WaveFunction, WaveFunction);
    
	if (Probability < 0.01)
	{
		return;
	}
    
	// Convert grid position to compute space coordinates
	float3 Center = float3(Id);
	float Scale = sqrt(Probability); // Scale vertices by sqrt of probability
    
	// Golden ratio for regular tetrahedron vertices
	static const float Phi = 1.618033988749895f;
	static const float3 TetrahedronVerts[4] = 
	{
		float3(Phi, 1.0f, 0.0f),
		float3(-1.0f, Phi, 0.0f),
		float3(0.0f, -1.0f, Phi),
		float3(0.0f, -1.0f, -Phi)
	};
    
	// Calculate base index for this tetrahedron in output buffer
	uint3 Sizes;
	Ping.GetDimensions(Sizes.x, Sizes.y, Sizes.z);
	uint BaseIndex = (Id.x + Id.y * Sizes.x + Id.z * Sizes.x * Sizes.y) * VERTICES_PER_TETRAHEDRON;
    
	// Generate the 4 triangles (12 vertices total)
	// Each set of 3 indices forms a triangle on the tetrahedron
	static const uint TriangleIndices[12] = 
	{
		0, 1, 2,  // Face 1
		0, 2, 3,  // Face 2
		0, 3, 1,  // Face 3
		1, 3, 2   // Face 4
	};
    
	// Write all vertices to the output buffer
	[unroll]
	for (uint i = 0; i < VERTICES_PER_TETRAHEDRON; i++)
	{
		// Get the tetrahedron vertex for this triangle vertex
		float3 Vertex = TetrahedronVerts[TriangleIndices[i]];
        
		// Scale, normalize and position the vertex
		Vertex = Center + Scale * normalize(Vertex);
        
		// Write to output buffer
		TriangleList[BaseIndex + i] = Vertex;
	}
}